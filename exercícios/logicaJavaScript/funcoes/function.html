<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funções em JavaScript</title>
    <link rel="stylesheet" href="/style/estilo.css">
</head>
<body>
    <h1>Funções em JavaScript</h1>
    De modo geral, uma função é um <strong>"subprograma"</strong> que pode ser chamado por código externo (ou interno, no caso de recursão) à função. Como o próprio programa, uma função é composta por uma sequência de instruções chamada <mark>corpo da função</mark> . Os valores podem ser passados para uma função como <mark>parâmetros</mark> e a função retornará um valor. Em JavaScript, <strong>as funções são objetos de primeira classe</strong> , porque podem ser passadas para outras funções, retornadas de funções e atribuídas a variáveis e propriedades. Eles também podem ter propriedades e métodos como qualquer outro objeto. O que os distingue de outros objetos é que as funções podem ser <mark>chamadas</mark>.</p>
    <figure class="codeSnap">
        <img src="/img/function.svg" alt="">
    </figure>

    <h3>Pontos importantes</h3>
    <ul>
        <li>Funções são conjuntos de instruções que podem ser executadas como um único comando.</li>
        <li>Permitem efetuar reúso de códigos, poupando muitas linhas de programação nos scripts.</li>
        <li>Podem receber parâmetros e retornar valores, ou simplismente executar uma tarefa.</li>
        <li>As funções podem ou não ter parâmetros;</li>
        <li>Os parâmetros passados para uma função são copiados para uma variávies locais;</li>
        <li>As funções podem ter acesso a variáveis externas;</li>
        <li>O código fora da função não vê as variáveis locais da funções;</li>
        <li>As funções podem retornar um valor. Se não o fizerem, o seu retorno será undefined.</li>
        <li>Funções podem ser usadas para processar valor, processar conversão e pode validar algo.</li>
    </ul>
    <h3>Sintáxe</h3>
    <pre>
        <code>
            function nomeFuncao(paramentros) {
                //bloco de instruções
                return
            }
            var chamadaDeFuncao = nomeFuncao(argumentos);
        </code>
    </pre>
    <p>Para tornar o código mais limpo, "não" é aconselhável usar variáveis dentro da função. Devemos passar os valores através de parâmentros. O uso de variáveis externa dentro das funções cria imensos problemas no uso de funções. As funçoes serão consideradas as "ações" que queremos que nosso código faça.</p>
    <p>Uma boa prática quando criamos uma função é nomear ela dando referência a ação que ela irá fazer em nosso código Exemplo:</p>
    <pre>
        <code>
            //esta funçao irá somar dois valores;
            function adicao_matematica(){
                //código
            }

            //esta função irá mostrar uma mensagem (texto)
            function mostrar_mensagem(texto){
                //código
            }

            /* Será boa prática também nomear a funçâo com verbos 
            criar...
            apresentar...
            buscar...
            verificar... 
            etc... */
        </code>
    </pre>
   
    
    <blockquote><strong>Observação:</strong> os construtores chamados com <mark>new</mark> têm um conjunto diferente de lógica para determinar seus valores de retorno.</blockquote>

    <h2>Função parametrizada</h2>
    <p>Uma função parametrizada é quando a função recebe valores externos a ela através de parâmetros. Os paramentros não são obrigatórios e quando são declarados é pelo motivo de que a função receberá valores externos a ela mesma. Também podem existir funções sem parâmetros que são chamadas de funções anônimas, que não receberam valores externos. Neste caso no cabeçalho da <strong>function</strong> será declarado apenas parenteses "()" vazio. Em teoria, os parâmetros tem funcionalidade de comunicar a <strong>function</strong> com o código externo a ela, no  arquivo javaScript</p>

    <h3>Parâmetros e Argumentos</h3>
    <p>Parâmetro é a variável que irá receber um valor em uma função (ou método) e ele é declarado, recebendo um nome criado, no cabeçalho da <strong>function</strong>. Enquanto que um argumento é o valor (que pode originar de uma variável ou expressão) que podemos passar para a função (ou método) que é declarado na chamada da <strong>function</strong>. Podemos declarar mais de um parâmetro para uma mesma <strong>function</strong>, separando-os com um operador de virgula ",". </p>
    <figure class="codeSnap">
        <img src="/img/code-parametros-argumento.png" alt="">
    </figure>
    <p></p>

    <h3>Passagem por valor e referência</h3>
    <p>Parâmetros primitivo, como strings, numéricos ou booleanos são passados <strong>por valor</strong>. Isso significa que se o argumento for alterado dentro da função, essa alteração <strong>não</strong> se reflete na variável do programa original(fora da função).</p>
    <p>Já os parâmetros do tipo objetos são passados <strong>por referência</strong>. Isso significa que se uma alteração for realizada no objeto dentro da função, a alteração irá se propagar para o objeto fora da função, no programa chamado. </p>
    <pre>
        <code>
            function valorReferencia(strVar, arrVar){
                strVar = "String modificada!";
                arrVar[0] = "Array modificada!";
            }
            var texto = "Valor original!";
            var vetor = ["Array original!"];
            console.log(`String antes de chamar função: ${texto}`);
            console.log(`Array antes de chamar função: ${vetor[0]}`);

            // Chamando a função;
            valorReferencia(texto, vetor)
            console.log(`String depois de chamar função: ${texto}`);
            console.log(`Array depois de chamar função: ${vetor[0]}`);

            run:
                String antes de chamar função: Valor original!
                Array antes de chamar função: Array original!
                String depois de chamar função: Valor original!
                Array depois de chamar função: Array modificada!
        </code>
    </pre>
    <h4>Pontos importantes no exemplo acima</h4>
    <ul>
        <li>A chamada da função no exemplo acima tem como argumentos referência aos valores das variáveis "texto" e "vetor" </li>
        <li>No exemplo notamos que o "array" da variável "vetor" mudou seu valor para 'Array modificada' após a função ser chamada </li>
    </ul>
    

    <h3>Parâmetro por padrão</h3>
    <p>Em JavaScript, padrões de funções são <mark>undefined</mark>. No entanto, em algumas situações pode ser útil definir um valor padrão diferente. Isto é onde os parâmetros padrão podem ajudar. No passado, a estratégia de definir valores padrão para parâmetros era testar os valores do parâmetros no corpo da função e atribuir um valor se este for <mark>undefined</mark>. </p>
    <p>Exemplo de como se definia o padrão de parâmetros de uma função no passado.</p>
    <pre>
            <code>
                function multiplicar(a, b) {
                    b = (typeof b !== 'undefined') ? b : 1;
                    return a * b;
                }

                multiplicar(10);

                run:
                        10
            </code>
        </pre>
        <h4>Pontos importantes no exemplo acima</h4>
        <ul>
            <li>O parâmetro 'b' não recebou valor como argumento na chamada da função, portanto seu valor padrão é <mark>undefined</mark>.</li>
            <li>O padrão de um parâmetro poderia ser definido no corpo de da função através de alguma estrutura condicional, neste caso foi utilizado uma operador ternário(se 'b' for diferente de 'undefined' será == b, se não será, == 1).</li>
        </ul>
        <p>Atualmete não é mais necessário definir o padrão de parâmetros no corpo da função. Agora podemos definir o padão no cabeçalho da função. Podemo declarar ao lado do parâmetro "=" mais o valor padrão queremos definir. Este valor padrão pode ser passado como <em>valor primitivo</em> ou como <em>valor por referência</em> através de uma variável por exemplo.</p>
        <p>Exemplo de como declarar um valor padrão para um parâmetro de função atualmente:</p>
        <pre>
            <code>
                function multiplicar(a, b=1) {
                    return a * b;
                }

                multiplicar(10);

                run:
                        10
            </code>
        </pre>

        <h3>Parâmetro rest</h3>
        <p>A versão ES6 do JavaScript fornece um novo tipo de parâmetro denominado parâmetro rest (repouso) que tem um prefixo de três pontos .... O parâmetro <strong>rest</strong> permite representar um número indefinido de argumentos como um array, ou seja, determina que <strong>não haverá</strong> um número maximo de parâmetros no cabeçalho da função.</p>
        <pre>
            <code>
                function soma(a, b, ...pRest){
                    //corpo da função
                }
            </code>
        </pre>
        <p>O último parâmetro "pRest" é prefixado com os três pontos "...", portando o "<em>...pRest</em>" é o parâmetro <strong>rest</strong> declarado no cabeçalho da função. Todos os argumentos que forem passados na função serão mapeados na lista de parâmetros. Na sintaxe acima, o primeiro argumento é mapeado para <em>"a"</em> o segundo mapeado para <em>"b"</em>, o terceiro, quarto e quaisquer outros a mais serão armazenados no parâmetro <strong>rest</strong> "<em>...pRest</em>" como sendo um array. </p>
        <pre>
            <code>
                soma(1, 5, 10, 'azul', true, '2023', 32);
            </code>
        </pre>
        <h4>Pontos importantes</h4>
        <ul>
            <li>Ao chamar a função "soma()" o parâmetro "...pRest" armazenará o valores  <strong>[10, 'azul', true, '2023', 32]</strong></li>
            <li>Se chamarsemos a função "soma()" com apenas dois argumentos, estes argumentos seriam mapeados para "a" e "b". E o argumento para "...pRest" seria igual a um array vasio "[]". </li>
            <li>Podemos observar que o parâmetro <strong>rest</strong> esta declarado como último argumento, essa é a norma para utiliaza-lo. Caso contrário, se "...pRest" for declarado antes do último parâmetro ocorrerá um erro:
            <code>Uncaught SyntaxError: Rest parameter must be last formal parameter</code></li>
        </ul>

        <p></p>
    <h2>Chamando uma função (executando-a)</h2>
    <p>A expressão <strong>chamar uma função</strong> significa que vamos utilizar essa função em algum ponto do programa. Para isso usamos o nome da função como uma instrução em algum ponto do script. Na sintaxe de chamada devemos sempre declarar parêntese "()" ao lado do nome da função, e se houver parâmetros devemos declarar o valor de argumento dentro de parêntese "()".</p>
    <pre>
        <code>
            function (texto) {
                console.log(`São 7 horas da manhã, ${texto}`);
            }

            mensagem(Bom dia!);// Esta é a chamada da função.

            run:
                São 7 horas da manhã, Bom dia!
        </code>
    </pre>
    <p>Ao ser executada, essa instrução faz com que o interpretador do javaScript transfira o controle à primeira instrução dentro da função, irá então interpretar suas instruções de acordo com o desejado. Uma função também poderá ser chamada por um evento, que pode ser evento de vários tipos, click do mouse, focus do mause, chage e etc. Também, uma função pode ser auto-invocada (ser executada automaticamente).</p>
    
    <h2>return</h2>
    <p> A instrução <dfn>return</dfn>  permite que você retorne um valor <em>arbitrário</em> da função. Uma chamada de função pode retornar apenas um valor, mas você pode simular o efeito de retornar vários valores retornando um objeto ou array e desestruturando o resultado. <strong>Valor de retorno</strong>, por padrão, se a execução de uma função não terminar em uma instrução <mark>return</mark> ou se a palavra-chave <mark>return</mark> não tiver uma expressão depois dela, o valor de retorno será <mark>undefined</mark>.</p>
    <pre>
        <code>
            function calcular(num1, num2) {
                let adicao = num1 + num2;
                return adicao
            }
            console.log(calcular(10,30));  
            
            run: 40

        </code>
    </pre>
    <h3>Pontos importantes no exemplo acima:</h3>
    <ul>
        <li>O <strong>"return"</strong> recebeu a variável <em>"adicao"</em> que contêm a expressão matemática com os parâmetros da função.</li>
        <l>A <strong>chamada de uma função</strong>, quando <em>"return"</em> esta retornando um valor, é diferente pois esta função não esta realizando um comando. Por isso quando chamamos o valor desta função será para repassa-lo para outra entidade do javaScript. no exemplo passamos este valor para um "console.log()", mas poderia ser para uma variável, uma estrutura condicional e etc.</l>
    </ul>


    <h2>Tipos de funções</h2>
    <p>No javaScript, atualmente, podemos programar scripts declarando cinco tipos de funções: sendo elas as seguintes:</p>
    <ul>
        <li>Functions declaration (Função de declaração)</li>
        <li>Functions expression (Função de expressão)</li>
        <li>Arrow Functions (Função de flecha)</li>
        <li>Functions constructor E function factory(Função construtora e função fábrica)</li>
        <li>Generator Functions (Função geradora)</li>
    </ul>

    <h3>Function declaration</h3>
    <p>O jeito mais básico de definir funções em JavaScript é através da <strong>function declaration</strong>, toda função de declaração começa com a palavra reservada e obrigatória <mark>function</mark>, seguida pelo nome da função (também obrigatório) e uma lista de parâmetros (opcionais) separados por vírgula e encapsulados em parenteses (obrigatórios), o último passo é definir as chaves (obrigatórias) que será o corpo da função.</p>
    <h4>Sintáxe</h4>
    <pre>
        <code>
            function mostrarExemplo(texto) {
                //corpo da função
            }
        </code>
    </pre>
    <h4>Exemplo</h4>
    <pre>
        <code>
            function ola() {
                console.log('Olá')
            }
            ola()
            
            function ola() {
                function mensagem() {
                    return 'Olá'
                }
                console.log(mensagem())
            }
            ola()
            
            function ola() {
                function mensagem() {
                    return 'Olá'
                }
                console.log(mensagem())
            }
            ola()
            
            console.log(mensagem()) // a função mensagem() não irá existir nesse trecho de código, ela somente existe dentro da função ola()
            
            function ola(nome) {
                console.log('Olá', nome)
            }
            ola('Rafael')
        </code>
    </pre>
    <h4>Pontos importantes no exemplo:</h4>
    <ul>
        <li>Em JavaScript podemos declarar funções dentro de funções.</li>
        <li>Uma função declarada dentro de outra, apenas irá viver durante o escopo da função pai, ou seja, a função mensagem apenas existe no escopo/bloco da função ola.</li>
    </ul>
    <h3>Function expression</h3>
    <p>No javaScript as funções são objetos, um tipo específico de valor. Como as funções são valores, podemos atribuí-las a uma variável. Desta forma, a função recebe a designação de <strong>function expression</strong>.</p>
    <h4>Sintáxe</h4>
    <pre>
        <code>
            let variavel = function() {
                //Corpo da função
            }
        </code>
    </pre>
    <h4>Exemplo</h4>
    <pre>
        <code>
            var helloWord = function() {
                console.log('hello Word!');
            };

            let novaFunction = helloWord;

            helloWord();
            novaFunction()

            run: hello Word!
        </code>
    </pre>
    <h4>Pontos importantes no exemplo</h4>
    <ul>
        <li>Quando atribuimos uma função para uma variável devemos declarar ";" no final.</li>
        <li>Agora a variável será chamada com parênteses "()" ao lado como uma função.</li>
        <li>Atribuir uma função a uma variável pode ser útil para definir a função exatamente onde ela precisa ser chamada, isso em alguns momentos pode tornar nosso código mais simples de entender.</li>
    </ul>

    <h3>Arrow Functions</h3>
    <p>Uma expressão <strong>arrow function</strong> possui uma sintaxe mais curta quando comparada a uma expressão de função (function expression) e não tem seu próprio <mark>this</mark>, <mark>argumentos</mark>, <mark>super</mark> ou <mark>new.target</mark>. Estas expressões de funções são melhor aplicadas para funções que não sejam métodos, e elas não podem ser usadas como construtoras (constructors). Tecnicamente <strong>arrow function</strong> é um conceito para funções do tipo <strong>lambda</strong>, que são funções anônimas mais concisas. tamabém podemos utiliza-la como <em>variável</em>, isso dignifica que podemos passa-la como argumento para outras funções ou retorna-la de funções também. </p>
    <h4>Sintaxe</h4>
    <pre>
        <code>
            let funcao = (parametros) => expressao;
        </code>
    </pre>
    <p>Esta sintáxe cria uma função que aceita argumentos como parâmetros e em seguida avalia uma expressão e depois já retorna um resultado de maneira implícita. Desta maneira a palavra reservada <strong>"function"</strong>, a abertura de blocos <strong>"{}"</strong> e o <strong>"return</strong>" estão presentes de maneira implícita. A função ficará designada através dos sinais <strong>"=>"</strong> que representam um flecha. Mas essa sintaxe somete será válida se o código da arrow function couber no espaço de uma linha apenas, caso contrário, deverá ser aberto um bloco com "{}" para escrever as expressões da função, e tambem se houver algum valor a ser retornado, devemos declarar a palavra reservada <strong>"return"</strong>.</p>
    <pre>
        <code>
            let soma = (num1, num2) => num1 + num2;
            console.log(soma(10, 20));

            run: 30
        </code>
    </pre>

    <h3>Function constructor e function factory</h3>
    <p>A <strong>função construtora</strong> em JavaScript <strong>é um método especial para criar e inicializar um objeto criado a partir de uma classe</strong>. são como as classes do Java, diferenciando apenas pela sintaxe. Em questão de funcionamento, tanto funções contrutoras no JavaScript quanto Classes no Java têm a mesma utilidade: servir de molde para a criação de objetos. Para construir objetos, funções construtoras precisam ser instanciadas pelo operador <mark>new</mark>. O <mark>this</mark> dentro delas se referencia ao objeto criado a partir delas.</p>
    <pre>
        <code>
            function carro(marca, modelo, ano){
                this.nomeMarca = marca;
                this.nomeModelo = modelo;
                this.numAno = ano;
            };
            let carro1 = new carro('Chager','RT', 1970);
            console.log(carro1);

            run: carro { nomeMarca: 'Chager', nomeModelo: 'RT', numAno: 1970 }
        </code>
    </pre>
    <p><strong>Factory Function</strong> é a implementação em javaScript de um dos padrões de projetos criacionais, o <em>Factory Method</em>, existente como em outras linguagens orientadas a objetos. Este padrão encapsula a criação de objetos a partir de um de seus métodos, funcionando como uma fábrica de objetos propriamente dita. As funções retornam um objeto sem a necessidade da utilização da palavra-chave <mark>new</mark>. Além disso, os métodos são criados no próprio objeto, não no prototype, o que oferece uma melhoria de performance em casos de <strong>instanciação</strong> de um elevado número de objetos em uma mesma factory function.</p>
    <p>Possuem basicamente a mesma função que as constructor functions e as classes. O retorno da função é puramente um objeto. Por convenção, o nome de uma factory function começa com letra minúscula(convensão de nomeclatura <strong>camelCase</strong>). Exemplo de uma função criadora de parágrafos:</p>
    <figure class="codeSnap">
        <img src="/img/code-factory-function.png" alt="">
    </figure>
    <h4>Pontos importantes no exemplo acima</h4>
    <ul>
        <li>O objeto tendo propriedade com o mesmo nome do parâmetro da função, a partir do ES6, dispensa a declaração explícita (<code>element: 'elemento', text: 'text'</code>). no corpo da função declaramos apenas (<code>elemento; text;</code>).</li>
        <li>Uma das vantagens da utilização factory é o isolamento de métodos e propriedades, tornando-os efetivamente privados. No exemplo acima as propriedades <em>color</em> e <em>background</em> não estão no retorno, portanto, inacessíveis, já a propriedade <em>text</em> está no retorno:
        <figure class="codeSnap">
            <img src="/img/code-propriedade-isolada.png" alt="">
        </figure></li>
        <li>Para impedir que métodos e propriedades sejam modificados há o padrão Ice Factory, utilizando <strong>Object.freeze()</strong> no retorno. Exemplo:
        <figure class="codeSnap">
            <img src="/img/code-object-freeze.png" alt="">
        </figure></li>
        <li>Além de dispensar a utilização da palavra-chave <mark>new</mark> para a inicialização, factory function pode ser utilizada com uma constructor function.</li>
    </ul>

    <h3>Generator Functions</h3>
    <p><strong>Generator Functions</strong> são funções cuja execução pode ser interrompida e posteriormente reconduzida. Seus contextos (de associações de variáveis) ficarão salvos entre cada recondução. Funções Geradoras em JavaScript, (especialmente quando combinados com Promises), são uma ferramenta muito poderosa para programação assíncrona, por diminuirem bastante os problemas com callbacks, como o Callback Hell e Inversão de Controle. Funções async são fundamentadas nisso.</p>
    <p>A declaração <strong>function*</strong> (palavra chave function seguida de um asterisco) define uma função geradora (generator function), que retorna um objeto Generator. e no corpo da função, declaramos a expressão <strong>yield</strong> mais o valor.</p>
    <h4>Sintaxe</h4>
    <pre>
        <code>
            function* fGeradora() {
                yield 'azul'
                yield 'verde'
            }
            const iterador = fGeradora();

            console.log(iterador.next().value)
            console.log(iterador.next().value);
        </code>
    </pre>
    <p>Chamar uma função geradora não executa seu conteúdo imediatamente; ao invés disso é retornado um objeto iterator. Quando o método next() do objeto iterator é chamado, o conteúdo da função do gerador é executado até a primeira expressão yield, que especifica o valor a ser devolvido do iterator ou com yield* que delega para outra função geradora. O método next() retorna um objeto com uma propriedade value contendo o valor retornado e a propriedade boolean: done indicando se o gerador produziu seu último valor. Chamar o método next() com um argumento resumirá a execução da função geradora, substituindo a expressão yield onde a execução foi pausada com o argumento de next().</p>
    <p>Uma expressão return em uma função geradora, quando executada, fará com que o gerador termine (isto é, a propriedade done do objeto retornado será atribuído com o valor true). Se um valor foi retornado, este será usado como <em>propriedade value</em> do objeto retornado pelo gerador. Semelhantemente a uma expressão return, um erro lançado dentro do gerador o terminará -- a não ser que tratado no corpo do gerador. Quando um gerador estiver terminado, chamadas next subsequentes não executarão nenhum código do gerador, retornarão simplesmente um objeto da seguinte forma: {value: undefined, done: true}.</p>


    <script src="/logicaJavaScript/funcoes/function.js"></script>

</body>
 
</html>

